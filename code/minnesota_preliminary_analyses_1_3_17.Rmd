---
title: "Preliminary analyses for Minnesota beta diversity"
output:
  pdf_document: default
  html_notebook: default
---

Description: Code for preparing and performing preliminary analysis on Minnesota 
beta diversity  
Author: Eric Le Tortorec  
Date: `r Sys.Date()`  
R version: `r R.Version()$version.string`  

##Table of contents
[Load necessary packages](#load_necessary_packages)  
[Prepare vector data](#prepare_vector_data)  
[Prepare other data](#prepare_other_data)  
[Calculate BBA points per unit](#calcualte_points_per_unit)  
[Create human land-use index with PCA](#human_land_use_pca)  
[Process and calculate human footprint index for each unit](#human_footprint_per_unit)  
[Compare human influence PCA and human footprint](#compare_pca_footprint)  
[Process and calculate forest loss per unit](#forest_loss_per_unit)  
[Prepare bird data](#prepare_bird_data)  

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# set global chunk options
knitr::opts_knit$set(root.dir = normalizePath('/Users/Eric/Dropbox/Eric/Work/JKL/Theses/Matti_Hakkila/paper_4/'))
```

##Load necessary packages {#load_necessary_packages}
```{r, results = 'hide'}
library(dplyr)
library(tidyr)
library(readxl)
library(maptools)
library(rgeos)
library(rgdal)
library(raster)
library(psych)
```

##Prepare vector data {#prepare_vector_data}
We prepare the vector data by joining all unit-level data together
```{r, results = 'hide'}
# Read the different unit-level shapefiles
units <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units.shp', 'Units')
units_census <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units_Census.shp', 'Units_Census')
units_eco_subsection <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units_EcoSubsection.shp', 'Units_EcoSubsection')
units_forest_status <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units_ForestStatus.shp', 'Units_ForestStatus')
units_land_fire <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units_Landfire.shp', 'Units_Landfire')
units_prism <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units_PRISM.shp', 'Units_PRISM')
units_road_density <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Units_RoadDensity.shp', 'Units_RoadDensity')
units_forest_loss <- readOGR('./data/forest_loss_3_2017/Units_ForestLoss.shp', 'Units_ForestLoss')

# Join attributes of unit- level shapefiles
units_merged <- units
units_merged <- merge(units_merged, units_eco_subsection, by = 'unit')
units_merged <- merge(units_merged, units_census, by = 'unit')
units_merged <- merge(units_merged, units_prism, by = 'unit')
units_merged <- merge(units_merged, units_forest_status, by = 'unit')
units_merged <- merge(units_merged, units_road_density, by = 'unit')
units_merged <- merge(units_merged, units_land_fire, by = 'unit')
units_merged <- merge(units_merged, units_forest_loss, by = 'unit')
units_merged@data$Dens_Minor <- as.numeric(units_merged@data$Dens_Minor)

# Save the joined data as a shapefile
writeOGR(units_merged, './data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/units_merged.shp', 'units_merged', driver = 'ESRI Shapefile', overwrite_layer = T)
```

We have a total of `r length(units)` units, and the combined unit object has a 
total of `r length(colnames(units_merged@data))` columns. The name and type of 
each column is:
```{r}
sapply(units_merged@data, class)
```

##Prepare other data {#prepare_other_data}
```{r, results = 'hide'}
forest_status_2 <- raster('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/forest_status/forstat_rast2.tif')
land_fire_3 <- raster('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/landfire/landfire3.tif')
units_merged <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/units_merged.shp', 'units_merged')
mnn_bba_points <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/bird_data/MNBBA_Surveys_DominantHabitat_Final.shp', 'MNBBA_Surveys_DominantHabitat_Final')
```

##Calculate BBA points per unit {#calcualte_points_per_unit}
Later on we will need to determine how many forested BBA points there are per 
unit. There are three ways of doing this, all of which will be performed and 
compared:

* Reclassify the forest status raster into two classes: forest and non-forest
* Reclassify the land_fire_3 raster into the same to classes
* Reclassify the land cover class of each point (this information is included 
in the BBA data) in the same two classes.

The first two approaches perform the reclassification, and then extract raster 
values to points, while the last approach simply reclassifies the assigned land 
cover class for each point.

The reclassifications for the last two approaches are such that forests are:

* Lowland Deciduous Forest
* Northern Hardwoods
* Pine Forest
* Boreal Deciduous
* Oak Forest
* Parkland Deciduous Forest
* Boreal Coniferous
* Lowland Coniferous Forest
* Rural Developed Forest
* Urban Developed Forest
* Pine-Oak Barrens
* Oak Savannah

Let's reclassify the forest_status raster
```{r, eval = FALSE}
reclass_matrix <- matrix(c(0, 3, 1, 5, Inf, 0), ncol = 3, byrow = TRUE)
forest_status_reclass <- reclassify(forest_status_2, reclass_matrix, right = NA)
forest_status_points <- extract(forest_status_reclass, mnn_bba_points)
forest_status_points[is.na(forest_status_points)] <- 0
mnn_bba_points@data$forest_forest_status <- forest_status_points
```

Then the land_fire_3 raster
```{r, eval = FALSE}
reclass_matrix <- matrix(c(2, 3, 0, 4, 8, 1, 9, 18, 0, 
  19, 25, 1, 26, 26, 0, 30, 51, 1), ncol = 3, byrow = TRUE)
land_fire_3_reclass <- reclassify(land_fire_3, reclass_matrix, right = NA)
land_fire_3_points <- extract(land_fire_3_reclass, mnn_bba_points)
land_fire_3_points[is.na(land_fire_3_points)] <- 0
mnn_bba_points@data$forest_land_fire_3 <- land_fire_3_points
```

Finally, we reclassify the Reclass3_5- column from mnna_bba_points (dominant 
landcover type within 50m of the BBA point, using the reclass3 classification)
```{r}
mnn_bba_points@data$forest_bba <- mnn_bba_points@data$Reclass3_5
levels(mnn_bba_points@data$forest_bba) <- list('1' = c("Boreal Coniferous", 
  "Boreal Coniferous_10m", "Boreal Deciduous", "Boreal Deciduous_10m", 
  "Lowland Coniferous Forest", "Lowland Coniferous Forest_10m", 
  "Lowland Deciduous Forest", "Lowland Deciduous Forest_10m", 
  "Northern Hardwoods", "Northern Hardwoods_10m", "Oak Forest", 
  "Oak Forest_10m", "Oak Savannah", "Parkland Deciduous Forest_10m", 
  "Pine Forest", "Pine Forest_10m", "Pine-Oak Barrens", "Pine-Oak Barrens_10m", 
  "Rural Developed Forest_10m", "Urban Developed Forest", 
  "Urban Developed Forest_10m"), '0' = c("Boreal Lowland Grassland", 
  "Boreal Shrub Swamp", "Cropland", "Developed-High Intensity", 
  "Developed-Low Intensity", "Developed-Medium Intensity", "Lowland Herbaceous", 
  "Open Water", "Quarries-Strip Mines-Gravel Pits", "Shrub Swamp", 
  "Upland Grassland", "Upland Native Grassland", "Upland Shrub"))
mnn_bba_points@data$forest_bba <- as.numeric(as.character(mnn_bba_points@data$forest_bba))
```

We then continue by calculating how many unique BBA points fall within each 
unit. It seems like some units have BBA points that have been counted in 
multiple years. For this, we use the 'block_poin' column in the BBA data to 
identify how many unique points there are.
```{r}
# Select unique points based on the 'block_poin' column
mnn_bba_points_unique <- mnn_bba_points[which(!duplicated(mnn_bba_points@data$block_poin)), ]
#mnn_bba_points_unique <- mnn_bba_points[which(!duplicated(mnn_bba_points@data[c('x', 'y')])), ]

# Calculate the number of unique BBA points within each unit
units_points <- over(mnn_bba_points_unique, units_merged)
units_points_count <- data.frame(table(units_points$unit))
colnames(units_points_count) <- c('unit', 'point_freq')
units_points_count$unit <- as.numeric(as.character(units_points_count$unit))
#units_points_freq <- left_join(units_merged@data, units_points_count)
units_merged <- merge(units_merged, units_points_count, by = 'unit')
units_merged@data$point_freq[is.na(units_merged@data$point_freq)] <- 0

# Summarise how many unique BBA points units have
point_freq <- as.data.frame(table(units_merged@data$point_freq))
colnames(point_freq) <- c('points per unit', 'freq')
print.data.frame(point_freq)
hist(units_merged@data$point_freq, breaks = 18, xlim = c(0, 20), xlab = 'Number 
of BBA points', main = 'BBA points per unit')
```

There are a total of `r length(mnn_bba_points_unique)` unique points out of a 
total of `r length(mnn_bba_points)` BBA points in the data. The number of unique 
forested BBA points dependes on the reclassification method:

* Reclassifying the forest_status raster results in 2076 unique points
* Reclassyfying the land_fire_3 raster results in 2054 points
* Reclassifying the dominant land cover class within 50m of BBA points results in `r sum(mnn_bba_points_unique@data$forest_bba)` points

Even though reclassifying the dominant land cover class of the BBA points yields 
the least points, we will use it since it has been measured directly in the 
field. Using this approach, we then calculate the number of forested BBA points 
per unit.
```{r}
# Select forest BBA points according to the forest reclassification approaches
#mnn_bba_points_forest_forest_status <- mnn_bba_points_unique[mnn_bba_points_unique@data$forest_forest_status == 1, ]
#mnn_bba_points_forest_land_fire_3 <- mnn_bba_points_unique[mnn_bba_points_unique@data$forest_land_fire_3 == 1, ]
mnn_bba_points_forest <- mnn_bba_points_unique[mnn_bba_points_unique@data$forest_bba == 1, ]

# Calculate the number of BBA points in forested pixels within each unit
units_forest_points <- over(mnn_bba_points_forest, units_merged)
units_forest_points_count <- data.frame(table(units_forest_points$unit))
colnames(units_forest_points_count) <- c('unit', 'forest_point_freq')
units_forest_points_count$unit <- as.numeric(as.character(units_forest_points_count$unit))

units_merged <- merge(units_merged, units_forest_points_count, by = 'unit')
units_merged@data$forest_point_freq[is.na(units_merged@data$forest_point_freq)] <- 0

# Summarise how many unique BBA points in forest pixels units have
forest_point_freq <- as.data.frame(table(units_merged@data$forest_point_freq))
colnames(forest_point_freq) <- c('forested points per unit', 'freq')
print.data.frame(forest_point_freq)
hist(units_merged@data$forest_point_freq, breaks = 15, xlim = c(0, 15), xlab = 'Number 
of forested BBA points', main = 'Forested BBA points per unit')
```

##Create human land-use index with PCA {#human_land_use_pca}
Let's begin by selecting land-use variables that describe human land-use. We 
want to study if human land-use causes biotic homogenisation. We can select the 
following variables from the merged unit data:

* sum of people per unit
* density of major highways per unit
* density of minor highways per unit
* density of other roads per unit
* proportion of quarries, strip mines and gravel pits
* proportion of low intensity development
* proportion of medium intensity development
* proportion of high intensity development
* proportion of cropland

```{r}
# Select variables for PCA
units_merged_pca <- dplyr::select(units_merged@data, censusSUM, Dens_Major, 
  Dens_Minor, Dens_Other, HabV15:HabV18, HabV26)

# Print scree plot, showing how many components to include in the PCA
VSS.scree(units_merged_pca, main = "scree plot")
```

2 or 3 components should be enough, let's perform the PCA and extract 3 factors
```{r}
# Perform PCA
human_gradient_pca <- principal(units_merged_pca, nfactors = 3, rotate="varimax",
  covar = F)
human_gradient_pca
```

We can see that the first principal component is highly correlated with 
population number, density of major highways and other roads, proportion of low 
intensity development, proportion of medium intensity development and proportion 
of high intensity development. The second principal component is correlated with 
the density of minor highways and croplands, and the third principal component 
with the proportion of quarries, strip mines and gravel pits.

The first component does a good job of summarising many aspects of human 
land-use, and captures 58% of the variation, while the next two are more 
specific and capture 12% of the variation, respectively.

Let's join the first component to the merged data
```{r}
units_merged@data$human_pca <- human_gradient_pca$scores[, 1]
```

##Process and calculate human footprint index for each unit {#human_footprint_per_unit}
I will continue by looking into calculating an index describing the intensity of 
the human footprint.

Then we read, clip and reproject the human footprint data so that average values 
per unit can be calculated. The first part of the code below reads, clips and 
reprojects the human footprint data. For some reason raster::projectRaster 
cannot reproject between WGS84 and UTM zone 15, even if the raster has been 
clipped to the spatial limits of zone 15. Thus, the clipped raster is saved as 
a geotiff, and reprojected with gdal in the terminal.
```{r, eval = FALSE}
minnesota <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/units_spatial_data/Minnesota_Outline.shp', 'Minnesota_Outline')
human_footprint_orig <- raster('./data/last_of_the_wild/human_footprint_2/hfp_n_amer/dblbnd.adf')
crs(human_footprint_orig) <- CRS("+init=epsg:4326")

minnesota_extent <- as(extent(minnesota), 'SpatialPolygons')
crs(minnesota_extent) <- crs(minnesota)

minnesota_extent_wgs84 <- spTransform(minnesota_extent, CRS = CRS('+init=epsg:4326'))
human_footprint_minnesota <- crop(human_footprint_orig, minnesota_extent_wgs84)

writeRaster(human_footprint_minnesota, filename = './Data/last_of_the_wild/human_footprint_2/human_footprint_minnesota.tif', overwrite =T)
gdalwarp -s_srs '+init=epsg:4326' -t_srs '+init=epsg:26915' human_footprint_minnesota.tif human_footprint_utm15n.tif
```

We then read the reprojected data and calculate the average human footprint 
value per unit, and merge it to the unit-level data
```{r}
human_footprint <- raster('./data/last_of_the_wild/human_footprint_2/human_footprint_utm15n.tif')
units_hfp <- extract(human_footprint, units, fun = mean, na.rm = T)
units_hfp <- data.frame(unit = seq(1, 617, 1), human_footprint = units_hfp)
units_merged <- merge(units_merged, units_hfp, by = 'unit')
```

##Compare human influence PCA and human footprint {#compare_pca_footprint}
Before comparing the pca and human footprint values we choose only units with 
at least two forested BBA points.
```{r}
# Select units that have at least 2 forested unique BBA points in them
min_points <- 2
units_merged_subset <- units_merged[units_merged@data$forest_point_freq >= min_points, ]
```

We can see that with a minimum of `r min_points` BBA points in forested pixels per unit, we 
have a total of `r dim(units_merged_subset)[1]` units.


Then, we print a scatter plot of pca vs. human footprint.
```{r}
plot(units_merged_subset$human_pca, units_merged_subset$human_footprint, xlab = 
    'Human influence principal component', ylab = 'Human footprint index')
```

Not bad! We have a Pearson's correlation coefficient of `r cor(units_merged_subset$human_pca, units_merged_subset$human_footprint, use = 'complete.obs')`, which means that the two 
indices pretty much capture the same variation in the data. I would suggest that 
we go with the human footprint index even though its time period does not match 
the bird data so well (1995 - 2004). The roads, railways, population etc. 
included in the calculation of the index are probably variables that won't 
change very quickly. In any case, the variables used in the PCA are not 
necessarily up to date with the bird data either.

...to be continued...

##Process and calculate forest loss per unit {#forest_loss_per_unit}
In addition to the index describing human land use we want to study if forest 
loss has an impact on beta diversity. We have forest loss data from Minnesota, 
which is derived from Hansen et al. 2013 (Science). The data has proportion 
forest loss between 2001-2014 per unit. Note that forest fires are also 
included! Edmund Zlonis said that data separating the two types of forest loss 
might be available in 6 months - 1 year, but this is too long. Let's use the 
data we have available and see if forest loss is correlated with human pressure.
```{r}
plot(units_merged_subset$human_footprint, units_merged_subset$allV1, ylab = 
    'Proportion forest loss 2001-2014', xlab = 'Human footprint index')
```

Looks good! There is a slight negative trend, but nothing clear. The Pearson's 
correlation coefficient is `r cor(units_merged_subset$human_footprint, units_merged_subset$allV1, use = 'complete.obs')`, probably strengthened somewhat by the single point at the top left corner.

##Prepare bird data {#prepare_bird_data}
First, let's load the bird data and print all unique bird species in the data:
```{r}
library(readxl)
bird_data_whole <- read_excel('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/bird_data/Homogenization_All_BirdData.xlsx')
sort(unique(bird_data_whole$common))
```

We then create a dataframe of unique BBA points, based on their coordinates. However, 
this cannot be directly used to calculate beta diversity, since there are several bird 
observations per point. One option might be to create a list of BBA ID's that are 
duplicates, and filter out all bird observations from these points. Now, we just use 
all of the available bird data.
```{r}
bird_points_unique <- dplyr::arrange(bird_data_whole, ID, Date) %>% 
  dplyr::select(ID, x, y) %>% dplyr::distinct(x, y, .keep_all = TRUE)

#bird_points_species <- dplyr::select(bird_data_whole, ID, common, Sum_AllBirds) %>% 
#  dplyr::arrange(ID, common)
# Filter out unidentified species
bird_points_species <- dplyr::select(bird_data_whole, ID, common, Sum_AllBirds) %>% 
  filter(!grepl('Unidentified', common)) %>% dplyr::arrange(ID, common)

bird_points_species_wide <- spread(bird_points_species, ID, Sum_AllBirds)
bird_points_species_wide[is.na(bird_points_species_wide)] <- 0
bird_points_species_wide <- as.data.frame(bird_points_species_wide)
rownames(bird_points_species_wide) <- bird_points_species_wide$common
bird_points_species_wide <- bird_points_species_wide[2:dim(bird_points_species_wide)[2]]

# Bah! It seems like the functional and phylogenetic matrices are compulsory. At this point 
# we don't have such things, so I created empty matrices to get the analysis to work.
funct_matrix <- matrix(data = 0, nrow =nrow(bird_points_species_wide), ncol = nrow(bird_points_species_wide))
phylo_matrix <- matrix(data = 0, nrow =nrow(bird_points_species_wide), ncol = nrow(bird_points_species_wide))

source("./Code/Rao.r")
bird_div <- Rao(sample = bird_points_species_wide, dfunc = funct_matrix, dphyl = phylo_matrix, weight = F, Jost = T, structure = NULL)
bird_beta_div <- bird_div$TD$Pairwise_samples$Beta_add
bird_beta_div_add <- as.data.frame(as.matrix(bird_div$TD$Pairwise_samples$Beta_add))
bird_beta_div_add[1:10, 1:2]
```