---
title: "Determining unique MNN BBA points"
output:
  pdf_document: default
  html_notebook: default
  html_document: default
---

Description: Code for exploring spatial patterns of BBA points, and determining 
what points are truly uniqe  
Author: Eric Le Tortorec  
Date: `r Sys.Date()`  
`r R.Version()$version.string`  

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# set global chunk options
knitr::opts_knit$set(root.dir = normalizePath('/Users/Eric/Dropbox/Eric/Work/JKL/Theses/Matti_Hakkila/paper_4/'))
```

Load necessary packages
```{r, results = 'hide'}
library(readxl)
library(tidyr)
library(dplyr)
library(plyr)
library(rgdal)
library(gstat)
library(raster)
```

Load data
```{r}
mnn_bba_points <- readOGR('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/bird_data/MNBBA_Surveys_DominantHabitat_Final.shp', 
  'MNBBA_Surveys_DominantHabitat_Final')
bird_data_whole <- read_excel('./data/minnesota_bird_data/mnbba_homogenization_data_9_22_2015/bird_data/Homogenization_All_BirdData.xlsx')
```


First, let's see how many points are duplicated. We will count how many points 
have duplicated coordinates, and how many have duplicated block_poin values. 
The block_poin values seem like a good candidate for identifying unique points 
since they indicate individual points within blocks.

**Coordinates:**
```{r}
coord_counts <- plyr::count(mnn_bba_points@data, c('x', 'y'))
table(coord_counts$freq)
coord_counts_dupl <- coord_counts[coord_counts$freq > 1, ]
```

We can see that the vast majority of points have uniqe coordinates, a few have 
one duplicate, and one is present three times!

**Block_poin values**
```{r}
block_poin_counts <- count(mnn_bba_points@data, 'block_poin')
table(block_poin_counts$freq)
block_poin_counts_dupl <- block_poin_counts[block_poin_counts$freq > 1, ]
```

Again, most of the points have unique block_poin values, but quite a few are 
duplicated. Continuing with the block_poin values, we can calculate how far 
apart pairs of points with identical block_poin values are.
```{r}
# All points with duplicated block_poin values
mnn_bba_points_dupl_block_poin <- mnn_bba_points[mnn_bba_points@data$block_poin 
  %in% block_poin_counts_dupl$block_poin, ]
mnn_bba_points_dupl_block_poin <- 
  mnn_bba_points_dupl_block_poin[order(mnn_bba_points_dupl_block_poin@data$block_poin), ]
# Make separate objects for each individual from each pair
mnn_bba_points_dupl_block_poin@data$order <- rep(c(1, 2), 
  length(mnn_bba_points_dupl_block_poin) / 2)
mnn_bba_points_dupl_block_poin_1 <- 
  mnn_bba_points_dupl_block_poin[mnn_bba_points_dupl_block_poin@data$order == 1, ]
mnn_bba_points_dupl_block_poin_2 <- 
  mnn_bba_points_dupl_block_poin[mnn_bba_points_dupl_block_poin@data$order == 2, ]
# Calculate the distance between each pair
dupl_block_poin_pair_distances <- pointDistance(mnn_bba_points_dupl_block_poin_1, 
  mnn_bba_points_dupl_block_poin_2)
dupl_block_poin_pair_distances <- data.frame(distance = dupl_block_poin_pair_distances, 
  block_poin = mnn_bba_points_dupl_block_poin_1@data$block_poin)
dupl_block_poin_pair_distances <- arrange(dupl_block_poin_pair_distances, distance)
summary(dupl_block_poin_pair_distances$distance)
hist(dupl_block_poin_pair_distances$distance, breaks = 50, main = 
    'Frequencies of distances between block_poin pairs', xlab = 
    'Distance between block_poin pairs (m)')
tail(dupl_block_poin_pair_distances, n = 10)
```

From the histogram we can see that most of the distances between pairs of points 
with identical block_poin values are very close to each other. In fact, `r  nrow(dupl_block_poin_pair_distances[dupl_block_poin_pair_distances$distance < 50, ])`
pairs of points have a distance of under 50m, and `r  nrow(dupl_block_poin_pair_distances[dupl_block_poin_pair_distances$distance == 0, ])` points have the 
same coordinates (i.e. a distance of exactly 0). BUT there are a number of 
points with rather large pair-wise distances. These range from several km to 
almost 50km, which means that it makes no sense to remove all duplicate values, 
since we would loose a whole bunch of data. If we leave out the outlying maximum 
value we can see that the mean distance between pairs of duplicates is `r mean(dupl_block_poin_pair_distances$distance[1:157])`m 
and the median is `r  median(dupl_block_poin_pair_distances$distance[1:157])`m. Let's continue 
by inspecting nearest neghbour distances for the whole data.

```{r}
point_dist <- pointDistance(mnn_bba_points, lonlat = FALSE)
point_dist <- as.data.frame(point_dist)
colnames(point_dist) <- mnn_bba_points@data$ID
rownames(point_dist) <- mnn_bba_points@data$ID
# Calcualte minimum distances, but leave zeros out, since they are present in 
# every row and column
point_dist_nn <- sapply(point_dist, FUN = function(x) {min(x[x > 0])})
point_dist_nn <- sort(point_dist_nn)
summary(point_dist_nn)
hist(point_dist_nn, breaks = 20, main = 'Frequencies of nearest neighbour 
  distances between points', 
  xlab = 'Nearest neighbour distance (m)')
```

It's a bit hard to determine a cut-off point since there is a contimuum of 
nearest neighbour values from `r min(point_dist_nn)`m all the way to `r max(point_dist_nn)`m. 
If we look at the smallest distances we can see that there is a small spike at 
the very smallest values (around 10-20m). However, there is a steady stream of 
small frequencies up to 200m. This is a bit odd considering that we would expect 
a smallish frequency of very small distances (points that have been counted 
twice), a gap, and then clearly larger distances between independent points.
```{r}
hist(point_dist_nn[1:1000], breaks = 20, main = 'Frequencies of nearest neighbour 
  distances between points', xlab = 'Nearest neighbour distance (m)')
```

Perhaps plotting a semivariogram can help use decide if there is a minimum 
nearest neighbour distance within which spatial autocorrelation causes problems?
```{r}
# Let's calculate the alpha diversity for each BBA point
bird_points_species <- dplyr::select(bird_data_whole, ID, common, Sum_AllBirds) %>% 
  filter(!grepl('Unidentified', common)) %>% dplyr::arrange(ID, common)
bird_points_species_wide <- spread(bird_points_species, ID, Sum_AllBirds)
bird_points_species_wide[is.na(bird_points_species_wide)] <- 0
bird_points_species_wide <- as.data.frame(bird_points_species_wide)
rownames(bird_points_species_wide) <- bird_points_species_wide$common
bird_points_species_wide <- bird_points_species_wide[2:dim(bird_points_species_wide)[2]]
# It seems like the functional and phylogenetic matrices are compulsory. At this point 
# we don't have such things, so I created empty matrices to get the analysis to work.
funct_matrix <- matrix(data = 0, nrow =nrow(bird_points_species_wide), 
  ncol = nrow(bird_points_species_wide))
phylo_matrix <- matrix(data = 0, nrow =nrow(bird_points_species_wide), 
  ncol = nrow(bird_points_species_wide))
source("./Code/Rao.r")
bird_div <- Rao(sample = bird_points_species_wide, dfunc = funct_matrix, 
  dphyl = phylo_matrix, weight = F, Jost = T, structure = NULL)
bird_div_alpha <- data.frame(alpha = bird_div$TD$Alpha)
bird_div_alpha$ID <- rownames(bird_div_alpha)

bird_data_unique_coord <- dplyr::arrange(bird_data_whole, ID, Date) %>% 
  dplyr::select(ID, x, y) %>% dplyr::distinct(x, y, .keep_all = TRUE) %>% 
  join(bird_div_alpha, by = 'ID', type = 'left')


#bird_points_id_wide <- dplyr::select(bird_data_whole, ID, common, Sum_AllBirds, x, y) %>% 
#  dplyr::arrange(ID, common)  %>% spread(common, Sum_AllBirds) %>% replace(is.na(.), 0)
#bird_point_variogram <- variogram(as.list(bird_points_id_wide$bird_sum), as.matrix(bird_points_id_wide[2:3]))

aaa <- gstat(id = "alpha", formula = alpha ~ x + y, location = ~ x + y, 
  data = bird_data_unique_coord)

bird_point_variogram <- variogram(aaa, width = ((3000) / 25), cutoff = (3000))
plot(bird_point_variogram)
```